**算法训练营**

# 0 week00

## 0.0 如何高效学习

### 0.0.1 视频

​		最好方法：1.5-2.0倍速播放，难点暂停反复看

​		最差方法： 原速看完，仅一遍，像看美剧

### 0.0.2 习惯

​		最好：不要死磕，10-15分钟做不出来放弃，敢于背正确代码；多过遍数，五毒神掌

​		最差： 一道题死磕2-3小时，没有精力了；题目只做一遍（90%素人，30%学员）

## 0.1 数据结构与算法总览

精通一个领域，职业训练需要三步：拆分知识点，可以练习，反馈

### 0.1.1 Chunk it up 切碎知识点

#### 1 数据结构

​		一维；二维； 特殊

#### 2 算法

​		基础：选择语句；循环语句；递归语句

​		高级： 搜索（广度，深度，启发式）；动态规划；二分查找；贪心；数学 几何

### 0.1.2 Deliberate Practicing 刻意练习

#### 1 五毒神掌

​		1 第一遍：5分钟读题和思考；10-15分钟做不出来直接看答案，多对比解法优劣；背诵并默写答案

​		2 第二遍： 不看答案自己写；对比多种解法，能否优化？

​		3 第三遍：24小时之后，复习

​		4 第四遍：一周之后复习

​		5 第五遍：面试前1-2周复习

​		最大误区四只做一遍

#### 2 多练习缺陷，弱点地方

### 0.1.3 Feedback 反馈

1 即时反馈

2 主动型反馈（GitHub， leetcode）

3 被动式反馈（code revie）

### 0.1.4 切题方法4件套

1 确保准确理解题目要求，可以和面试官沟通

2 多想可能解法，对比他们的时空复杂度

3 写

4 给出几个测试用例

## 0.2 训练准备和复杂度分析

### 0.2.1 训练环境设置、编码技巧和Code Style

#### 1 电脑设置

#### 2 快捷键

​		跳到行头行尾: command + left/right

​		删除光标右侧：fn + delete

​		光标按单词切分: option + left/right

​		选中整行： shift + commoand + right

​		option + return

​		打开最近文件: command E

​		搜索： top tips pycharm

#### 3  自顶向下的编程方式

​		最关键的逻辑放到最上面，细节放到最后面

### 0.2.2  时间复杂度和空间复杂度分析

#### 1 空间复杂度

递归

​		主定理 master Theorem

​		以下四种情况需要记住

​		排好序二分查找：O（log2（n））

​		二叉树遍历： O（n）

​		排好序二维矩阵二分查找：O（n）

​		归并排序： O（nlogn）

#### 2 空间复杂度

​		两条原则：数组的长度；递归的深度；取最大值

# 1 week01 数组、链表、跳表、栈和队列

## 1.1 数组、链表、跳表的基本实现和特性

### 1.1.1 数组 array

查找快，头尾删除插入快，中间插入删除慢

### 1.1.2 链表 linked list

任意位置插入删除都快，遍历查找慢

LRU cache

### 1.1.3 跳表 skip list

redis 

升维思想，空间换时间

算是综合了数组和链表，查找速度从链表的O（n）提升到了O（logn）

空间复杂度为n + n/2 + n/4 +...+2= n(1+1/2+1/4+1/0.5n),收敛的调和级数，为kn，总之空间复杂度为O（n），但是肯定比链表多一些

### 1.1.4 时空对比

|      | 查找元素时间复杂度 | 头尾增删元素时间复杂度 | 中间位置增删元素时间复杂度 | 空间复杂度 |
| ---- | ------------------ | ---------------------- | -------------------------- | ---------- |
| 数组 | **O（1）**         | O（1）                 | **O（n）**                 | **O(n)**   |
| 链表 | **O(n)**           | O(1)                   | **O(1)**                   | **O(n)**   |
| 跳表 | **O(log2n)**       | O(1)                   | **O(log2n)**               | **O(n)**   |

## 1.2  栈和队列的实现与特性

### 1.2.1 栈 stack

​	后进先出 Last in -  First out（LIFO）

​	增加删除操作为O（1），查询为O（n）（因为是无序的）

### 1.2.2 队列 queue

​	先进先出

​	增加删除操作为O（1），查询为O（n）（因为是无序的）

### 1.2.3 deque：Double-End Queue 双端队列

​	栈和队列的结合体

​	两端都可以进出

​	插入删除操作为O（1），查询为O（n）（因为是无序的）

### 1.2.4 Priority Queue 优先队列

​	插入O（1）

​	取出O（logN）按照元素的优先级取出

​	python的优先队列用heapq 接口实现

​	高性能的container库，里面有deque

​	